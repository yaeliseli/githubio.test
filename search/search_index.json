{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-dhtks-documentation","title":"Welcome to DHTK's documentation!","text":"<p>In recent years, the digital humanities have received particular attention from both the humanities community and from computer science. Scholars working in Digital Humanities research often need to access to a range of data regarding cultural data.</p> <p>The Internet is a great source for searching and retrieving this type of information, and archives such as Project Gutenberg, Europeana, Archive.org, and similia, provide many datasets relevant to the research scientists. However, many of these resources are organized and structured in different ways and are often incompatible, having different APIs and different metadata structures, which make these repositories difficult to exploit.</p> <p>In addition, a number of powerful automated methods for analyzing text, sound, and images have been developed, but these tools are technically difficult or do not adequately fit the needs of the humanities community.</p> <p>As a result, finding resources, checking metadata, and finally processing cultural data and metadata, can be a long, tedious, and complex process.</p> <p>By introducing the Digital Humanities Tool Kit (DHTK), we propose a new python library whose purpose is to overcome these limitations by providing an intuitive tool for large-scale study of large cultural databases, exploiting state-of-the-art computational methods to support and simplify research in the Digital Humanities.</p> <p>Features</p> <ul> <li>Easy to use</li> <li>Access to a wide range of literary works</li> <li>The ability to analyze resources in an extended way</li> <li>Efficient and time effective</li> </ul> <p>Publications</p> <ul> <li>Davide Picca and Mattia Egloff, DHTK: The Digital Humanities     ToolKit,     WHiSe 2017</li> <li>Mattia Egloff, Alessandro Adamou, Davide Picca, Enabling     Ontology-Based Data Access to Project     Gutenberg, WHiSe 2020</li> </ul> <p>Changelog</p>  Version 1.0.2  <ul> <li> Unified framework for simplified programmatic access </li> <li> Modularisation and addition of \"module wrapper template\" for easier  integration of additional modules</li> <li> Automated DHTK's system check, including local Docker installation and configuration checks for local endpoints (macOS only)</li> </ul> Version 1.0.1  <ul> <li>*\"Clean Text\"* module to remove Gutenberg's header, footer and         footnotes</li> <li>*\"Test\"* files that will help us provide you with a stable working         toolkit, as well as help in adding new features and implementing         contributions from the community</li> </ul>"},{"location":"about/","title":"Community","text":"<p>We are proud to say that the DHTK community is growing continuously. Being created by the researchers of the \"Informatique pour les Sciences Humaines\" of the University of Lausanne, the project has seen an increased interest from both the teachers of other sections and the students, both from Bachelor and Master programs. DHTK was also presented at the Second Workshop on Humanities in the Semantic Web (WHiSeII) co-located with 16th International Semantic Web Conference (ISWC 2017), held in Vienna, Austria in 2017. Multiple visitors of the workshop have expressed interest in DHTK and the project was well received. As such, people from different walks of life from different parts of the world have already become a part of our community. You can do so too by contributing to this open source project.</p>"},{"location":"about/#contributors","title":"Contributors","text":""},{"location":"about/#project-manager","title":"Project Manager","text":"<ul> <li>Davide Picca</li> </ul> <p>Maitre d'Enseignement et de Recherche at the department of Language and Information Science at the University of Lausanne (Switzerland).</p>"},{"location":"about/#technical-leader","title":"Technical Leader","text":"<ul> <li>Mattia Egloff</li> </ul> <p>Phd Candidate and researcher at the department of Language and Information Science at the University of Lausanne (Switzerland).</p>"},{"location":"about/#main-developers","title":"Main Developers","text":"<ul> <li>Alessandro Amadou</li> </ul> <p>Research fellow at the Insight Centre for Data Analytics, National University of Ireland, Galway.</p> <ul> <li>Carlos Neves</li> </ul> <p>FNS Senior Researcher at UNIL.</p>"},{"location":"about/#student-contributors","title":"Student Contributors","text":"<p>Thanks to all students of UNIL's Python object oriented programming class contribute to the project.</p>"},{"location":"about/#past-contributors","title":"Past Contributors","text":"<p>Everyone who has collaborated with us so far, is still not giving up on the project! :-)</p>"},{"location":"dev_guide/","title":"Developer's Guide","text":"<p>DHTK is an open-source team effort. Contributions are essential to our survival and growth. We are thankful for any contribution and are happy to welcome you to the DHTK community!</p> <p>You can contribute to DHTK in many ways: -   Contribute to the development of new extensions -   Sending us feedback with suggestions or let us know of any issue you     run into while using DHTK. -   Add or modify minor functionalities to DHTK</p>"},{"location":"dev_guide/#new-data-sources","title":"New data sources","text":"<p>If you would like to integrate a new dataset to DHTK, please write to Davide Picca to let us know!</p> <p>DHTK modular structure is thought out to simplify integrating new modules, features and datasets. DHTK is technically divided into three parts as described in the documentation page. The three parts are organised in separate directories (core, data sources, storage) for easier identification and navigation during development. This guarantees that the new data sources functions as a self-contained module, independent of the core DHTK modules.</p> <p>Set up DHTK</p> <ol> <li>Please visit our GitHub page to find     detailed information on how to contribute.</li> <li>Add an issue to the repository to let us know what you will be     working on and request the access<sup>1</sup>.</li> <li>Clone the DHTK repository and create your own branch.</li> </ol> <p>Develop module</p> <ol> <li>Develop you module independently.</li> <li>Remember to re-use (import) functions and classes already available     on DHTK (how to add/modify helpers)</li> </ol> <p>Integrate module</p> <ol> <li>Creating a new folder under the extension directory with the new     module's name.</li> <li>If you're using a new curated dataset, make the RDF file available     (see RDF Dataset)</li> <li>Integrate your module (after testing) into DHTK's framework (see     Integrating new modules)</li> <li>Submit your changes for review as a pull request.</li> </ol> <p>Your request will be discussed and reviewed and soon as possibly using the normal Github interface.</p>"},{"location":"dev_guide/#integrating-new-modules","title":"Integrating new modules","text":"<p>DHTK core module is responsible to locate and load any module within the data source directory. Due to the modular architecture of DHTK, these data sources can be easily developed as self-sufficient Python modules, which are integrated into the DHTK framework through their path <code>dhtk.data_sources.gutenberg</code> for example.</p> <p>Note:</p> <p>All dhtk data sources should be named <code>dhtk.data_source.DATASOURCE_NAME</code> (i.e. <code>dhtk.data_source.gutenberg</code>) so that everyone can find them on the net.</p>"},{"location":"dev_guide/#procedure","title":"Procedure","text":"<p>We provide 4 different data storages already setup  and ready to use. - <code>dhtk_data_source_dummysql</code>: blueprint package to be used if you need SQL storage (MariaDB) - <code>dhtk_data_source_dummynosql</code>: blueprint package to be used if you need NoSQL storage (MongoDB) - <code>dhtk_data_source_dummytei</code>: blueprint package to be used if you need XML-TEI storage (BaseX) - <code>dhtk_data_source_dummytriplestore</code>: blueprint package to be used if you need RDF storage (Fuseki)</p> <p>Creating a data source</p> <p></p> <ol> <li>Clone one of the 4 bleuprint available</li> <li>Define <code>name</code>and <code>data_file</code> variables as shown in Figure 1 </li> <li>Complete the Module class by defining at least the required     attributes and methods: <code>get_data_file</code> , <code>__init__</code> and <code>get</code></li> <li>Update the <code>README.md</code> and <code>setup.py</code> to make the module installable.</li> </ol> <p>Data source integration into dhtk</p> <p>The DHTK <code>AbstractDataSource</code> abstract class contains most of the required methods to prepare a module for use. The new Module class is essentially a wrapper around a DHTK data source, defining the attributes name and url (name of the data source and location of the RDF data file to use on with the local SPARQL endpoint), and the methods to query and save the results. Any additional method that improves the Module class can be freely included.</p> <p>*Gutenberg example*</p> <p>1. Create a module specific directory: The gutenberg subdirectory was created on the dhtk's extension directory. All the files from the previously tested independent module are moved to this folder.</p> <p></p> <p>2. Add the class named Module to the __init__ file</p> <p>3.1. Defining attributes</p> <p>The general attributes name and url can be defined withing the class' __init__ method:</p> <ul> <li>name defines the the name of the module and should be the same as     the directory place under dhtk/extensions</li> <li>url define the remote location of the dataset to be set up     locally.</li> </ul> <p>note</p> <p>More specific attributes are defined to better integrate the gutenberg  module: _corpus and wrapper. In this case, _corpus is used  store retrieved books while the wrapper attribute is used to  reference the GutenbergData \"query\" object</p> <p>3.2. Defining .get and .save methods</p> <p>Two methods are required to be defined: .get() and save().</p> <p>The get(what, name, add) provides functions as the main point for DHTK integration. This method takes three arguments, converts then into SPARQL queries using a conditional logic and calls the correct module functionalities to retrieve information.</p> <ul> <li>what: a string value determining what is being searched for     (e.g. books, authors). This value is evaluated by a conditional     if-then-else logic, wrapping around the main module query calls with     a user-friendly and unified framework.</li> <li>name: a string value identifying of what is being searched (e.g.     book name, author name). This value is used to narrow down the     general query defined by what, retrieving specific instances.</li> <li>add: a boolean value defining if the query results should be added     to the records (e.g. corpus) or if the user wishes to search     interactively instead.</li> </ul> <p>The records generated when using get(add=True) are used by the .save() method to store all the retrieved data on disk by calling all relevant methods from the extension.</p> <p>3.3. Defining additional methods</p> <p>Gutenberg's Module class contains two extra methods. The suggested welcome() method automatically provides the user with the dataset statistics. This method is automatically called when a module is loaded, and can be used to provide the user with any (or no) information.</p> <p>The corpus method is not defined in parent AbstractExtension class, but it provides a simpler way to modify a corpus' settings and retrieve its representation, being a convenient intermediate method to search for book and author information.</p>"},{"location":"dev_guide/#feedback-and-issues","title":"Feedback and issues","text":"<p>As DHTK grows, we aim to make it more efficient, simpler and contain more functionalities relevant to the Digital Humanities' community. Even if you do not have the computational expertise to program in Python, you can contribute as part of the DHTK community by letting us know how to improve DHTK to best fit your research needs.</p> <p>If you have any question, suggestion or feedback please write to Davide Picca \\&lt;https://www.unil.ch/sli/davidepicca&gt;</p> <p>All suggestions and feedback are welcomed!</p>"},{"location":"dev_guide/#minor-changes","title":"Minor changes","text":"<p>If you think DHTK is missing some simple functionality or could be made simpler and easier in some way, and you want to contribute by helping us implement those changes, thank you! However, before you do so, please write to Davide Picca to let us know!</p> <p>As a collective effort, we remain an open to everyone's contributions. Everyone can add or modify any function, class or method to improve DHTK usability of an existing DHTK module easily:</p> <ol> <li>Please visit our GitLab page to     find detailed information on how to contribute.</li> <li>Add an issue to the repository to let us know what you will be     working on.</li> <li>Clone the DHTK repository and create your own branch.</li> <li>Address the issue by modifying and testing the code locally.</li> <li>Submit your changes for review as a pull request.</li> </ol> <p>Your request will be discussed and reviewed and soon as possibly using the normal Github interface.</p>"},{"location":"dev_guide/#rdf-dataset","title":"RDF Dataset","text":"<p>If the new extension module uses a new pre-processed dataset, the finalised RDF file should be made available to download so it can be added to the local Fuseki endpoint. These files can be stored in any remote location, as long as freely accessible, though we would recommend using Zenodo.</p> <p>For reproducibility and transparency, the full pipeline used to produce the provided RDF file (including clear instructions on how to use it) should also be made available under the \"builder directory\" of the module (e.g. dhtk/extensions/gutenberg/builder/)</p> <ol> <li> <p>DHTK will be soon publicly available.\u00a0\u21a9</p> </li> </ol>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<ul> <li>What is DHTK?</li> </ul> <p>DHTK stands for Digital Humanities ToolKit. Its purpose is to connect two very different disciplines: Humanities and Computer Sciences. At the moment, DHTK focuses on interacting with the Gutenberg database in tandem with DBpedia to provide access to literary works and their associated metadata in an easy and intuitive way. However, being modular, we expect DHTK functionalities to quickly grow and support different areas of research.</p> <ul> <li>How do I use DHTK?</li> </ul> <p>You can find information on how to install DHTK as well as the getting started guide on the Gettting Started page.</p> <ul> <li>I would like to have access to some of more technical information related to DHTK</li> </ul> <p>Complete technical information is available in the <code>DHTK Architecture &lt;./architecture.html&gt;</code>_ page, which contains further links to more detailed information about DHTK internal structure.</p> <ul> <li>I want to contribute to DHTK, how can I contact you?</li> </ul> <p>Thank you for your interesting in joining our effort. If you are interested in developing or improving DHTK you can find instructions and contact form on the <code>Community &lt;./community.html&gt;</code>_ page.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#start-with-dhtk","title":"Start with DHTK","text":"<p>As a Python module, DHTK can be accessed from any Python console or environment by importing it as normally.</p>"},{"location":"getting_started/#import-dhtk","title":"Import dhtk","text":"<pre><code>import dhtk\n # ###################################################\n # Welcome to the Digital Humanities ToolKit,\n # the  user - friendly Python API for\n # Digital Humanities research.\n #\n # For more information, please visit DHTK 's website:\n # [https://dhtk.unil.ch/]\n # ####################################################\n</code></pre> <p>DHTK contains a number of options to help users start up faster and automatically, most of which have a default value. The settings to pay more attention to are the following:</p> <ul> <li>[wd]: DHTK uses the user' home directory to set up its working     directory. This can be modified if another directory would be more     suitable.</li> <li>[dataset]: DHTK is a modular package to which extensions can be easily added.      This setting determines the available     extension modules that DHTK should load.</li> <li>[endpoint]: To use a remote (on-line) endpoint, it can be done by adding the URL (link) to the     remote endpoint. To use a local  server endpoint for querying pre-processed datasets use [storage] configuration.</li> <li>[storage]:  To use a remote (on-line) endpoint, it can be done by adding the URL (link) to the     remote endpoint. To use a remote  server endpoint for querying pre-processed datasets use [endpoint] configuration.</li> </ul> <p>DHTK is flexible and can accept several input formats. Hereunder, there are several working examples:</p>"},{"location":"getting_started/#set-dhtk-configuration-file","title":"Set DHTK configuration file","text":"<pre><code>import dhtk\nd  = dhtk.start(\"WD\", config={\"gutenberg\": {\"storage\":  \"docker\"}, \"auchinleck\": {\"storage\": \"docker\" }})\n\nd = dhtk.start(\"WD\", config={\"gutenberg\":{'triplestore' : {\"storage\":  \"docker\"}}})\n\nd =dhtk.start(\"WD\", data_source=\"gutenberg\", storage=\"docker\")\n\nd = dhtk.start(\"WD\", data_sources=[\"gutenberg\", \"auchinleck\"], storage=\"docker\")\n\nd = dhtk.start(\"WD\", gutenberg={\"storage\": \"docker\"}, auchinleck={\"endpoint\": \"http://localhost:3031/ds/sparql\" } )\n\n</code></pre>"},{"location":"getting_started/#load-the-module","title":"Load the module","text":"<p>Modules are automatically loaded using the dhtk.start() function.  In this guided example, we will illustrate using the original Gutenberg DHTK data source.  This dataset allows the user to easily query https://www.gutenberg.org/ for books, authors, bookshelves and subjects, retrieving all the available information as a DHTK Corpus.</p>"},{"location":"getting_started/#access-the-data","title":"Access the data","text":"<p>Authors are searched using the what=\"author\" argument. This will return a Python list containing all authors. To access a particular author, users must pass the author's name to the name argument.</p> <pre><code>authors = gutenberg.get(what=\"author\", name=\"Shelley\")\nauthors\n# {'Percy Bysshe Shelley': &lt;Author: Shelley, Percy (http://www.gutenberg.org/2009/agents/1529&gt;),\n# 'Henry Charles Shelley': &lt;Author: Shelley, Henry (http://www.gutenberg.org/2009/agents/2162&gt;),\n# 'Mary Wollstonecraft Shelley': &lt;Author: Shelley, Mary (http://www.gutenberg.org/2009/agents/61&gt;)}\n</code></pre> <p>then to access to Mary Wollstonecraft Shelley GutenbergAuthor object.</p> <pre><code>&gt;&gt; authors['Mary Wollstonecraft Shelley']\n# &lt;Author: Shelley, Mary (http://www.gutenberg.org/2009/agents/61&gt;)\n</code></pre> <p>Similarly, Books are searched using the what=\"book\" argument. This will return a list containing all books.</p> <pre><code>books = gutenberg.get(what=\"books\", name=\"Frankenstein\")\nbooks\n# {'Frankenstein; Or, Th (41445)': &lt;GutenbergBook: Mary Wollstonecraft Shelley - Frankenstein; Or, The Modern Prometheus gutenberg_id: 41445&gt;,\n# 'Frankenstein; Or, Th (42324)': &lt;GutenbergBook: Mary Wollstonecraft Shelley - Frankenstein; Or, The Modern Prometheus gutenberg_id: 42324&gt;,\n# 'Frankenstein; Or, Th (84)': &lt;GutenbergBook: Mary Wollstonecraft Shelley - Frankenstein; Or, The Modern Prometheus gutenberg_id: 84&gt;}\nbooks[\"Frankenstein; Or, Th (84)\"]\n# &lt;GutenbergBook: Mary Wollstonecraft Shelley - Frankenstein; Or, The Modern Prometheus gutenberg_id: 84&gt;\n</code></pre> <p>and retrieve a specific book.</p> <pre><code>book = books['Frankenstein; Or, Th (84)']\n</code></pre> <p>DHTK allows users to get access to metadata on a given book (or author) built on information collected in Project Gutenberg.</p> <pre><code>book.print_info()\n# Title       : Frankenstein; Or, The Modern Prometheus\n# Author      : Mary Wollstonecraft Shelley\n# Metadata    :\n#     - subject     :\n#             - Horror tales\n#             - Scientists--Fiction\n#             - Gothic fiction\n#             - Frankenstein, Victor (Fictitious character)--Fiction\n#             - Monsters--Fiction\n#             - Frankenstein's monster (Fictitious character)--Fiction\n#             - Science fiction\n#     - bookshelf   :\n#             - Precursors of Science Fiction\n#             - Science Fiction by Women\n#             - Movie Books\n#             - Gothic Fiction\n#     - gutenberg_id: http://www.gutenberg.org/ebooks/84\n#     - gutenberg_type: http://www.gutenberg.org/2009/pgterms/ebook\n#     - gutenberg_downloads:        34221\n#     - gutenberg_publisher: Project Gutenberg\n#     - gutenberg_hasFormat:\n#             - http://www.gutenberg.org/files/84/84-h.zip\n#             - http://www.gutenberg.org/files/84/84-0.txt\n#             - http://www.gutenberg.org/ebooks/84.kindle.images\n#             - http://www.gutenberg.org/ebooks/84.epub.images\n#             - http://www.gutenberg.org/ebooks/84.epub.noimages\n#             - http://www.gutenberg.org/cache/epub/84/pg84.cover.medium.jpg\n#             - http://www.gutenberg.org/ebooks/84.rdf\n#             - http://www.gutenberg.org/files/84/84-h/84-h.htm\n#             - http://www.gutenberg.org/cache/epub/84/pg84.cover.small.jpg\n#             - http://www.gutenberg.org/files/84/84-0.zip\n#             - http://www.gutenberg.org/ebooks/84.kindle.noimages\n#     - gutenberg_language:           en\n#     - gutenberg_rights: Public domain in the USA.\n#     - gutenberg_title: Frankenstein; Or, The Modern Prometheus\n#     - gutenberg_issued:   1993-10-01\n#     - gutenberg_creator: http://www.gutenberg.org/2009/agents/61\n#     - gutenberg_license: http://www.gutenberg.org/license\n#     - gutenberg_description: There is an improved edition of this title, eBook #42324\nmetadata = book.get_metadata()\n</code></pre> <p>to know more`</p> <p>please refer to the user guide page</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#install-python","title":"Install Python","text":"<p>As DHTK is a Python modules, make sure you have Python installed on your system. You can do this in three different ways:</p> <ol> <li>Manually search the common locations where your system saves     applications.</li> <li>You can use the search file options from you system to find the     Python application</li> <li>You can type python --version on your command line or powershell     (Windows)</li> </ol> <p>If you don't have Python 3 installs, please download it and follow the instructions. We recommend using the most up-to-date Python 3 version, but DHTK is compatible with at least Python 3.7+.</p>"},{"location":"installation/#install-docker","title":"Install Docker","text":"<p>In addition to Python 3, you are likely to use a local SPARQL endpoint when using DHTK to search pre-processed data. This requires setting up a Fuseki server container on the Docker application. To do so, you will need to download Docker before running DHTK.</p> <p>note</p> <p>DHTK may attempt to install docker (macOS systems only) and set up all  required containers and volumes.</p>"},{"location":"installation/#install-dhtk","title":"Install DHTK","text":"<p>DHTK can be installed as a regular python modules, using the package installer for Python (pip):</p> <pre><code>$ pip install git+https://gitlab.com/dhtk/dhtk.git\n</code></pre> <p>Alternatively, you may download the DHTK source code in your preferred format. Once you extract the DHTK files from the archive, you can access them via command line (or powershell).</p> <pre><code>$ cd dhtk\n$\n$ python setup.py  # or\n$ pip install .\n</code></pre>"},{"location":"installation/#install-extensions","title":"Install extensions","text":"<p>DHTK Extensions can be installed as a regular python modules, using the package installer for Python (pip):</p> <pre><code>$ pip install git+https://gitlab.com/dhtk/dhtk-extensions/dhtk-extension-&lt;name_extension&gt;.git\n</code></pre> <p>where  has to be replaced with the name of the extension you wish to install (i.e https://gitlab.com/dhtk/dhtk-extensions/dhtk-extension-gutenberg.git) <p>Alternatively, you may download the DHTK source code in your preferred format. Once you extract the DHTK files from the archive, you can access them via command line (or powershell).</p> <pre><code>$ cd dhtk\n$\n$ python setup.py  # or\n$ pip install .\n</code></pre> <p>note</p> <p>DHTK runs a number of system check to try to guarantee if can run  without any problem. If this is the first time you're running it, keep  in mind that it may take considerable time to complete the the full  set.</p>"},{"location":"user_guide/","title":"User Guide","text":""},{"location":"user_guide/#start-dhtk","title":"Start DHTK","text":""},{"location":"user_guide/#loading-dhtk","title":"Loading DHTK","text":"<p>As a Python module, DHTK can be accessed from any Python console or environment by importing it as normally.</p>"},{"location":"user_guide/#setting-up-configurations","title":"Setting up Configurations","text":"<p>The first step to use DHTK is to set the configurations to use by calling dhtk.start()</p> <p>This function instantiates DHTK's settings manager class, which searches for the user's saved settings. It automatically prints all current settings for the user's information.</p> <p>DHTK contains a number of options to help users start up faster and automatically, most of which have a default value. The settings to pay more attention to are the following:</p> <ul> <li>[wd]: DHTK uses the user' home directory to set up its working   directory. This can be modified if another directory would be more   suitable.</li> <li>[dataset]: DHTK is a modular package to which extensions can be   easily added. This setting determines which of the available   extension modules DHTK should load.</li> <li>[endpoint]: To use a remote (on-line) endpoint, it can be done by adding the URL (link) to the   remote endpoint. To use a local  server endpoint for querying pre-processed datasets use [storage] configuration.</li> <li>[storage]:  To use a remote (on-line) endpoint, it can be done by adding the URL (link) to the   remote endpoint. To use a remote  server endpoint for querying pre-processed datasets use [endpoint] configuration.</li> </ul> <p>note</p> <p>Dataset does not have a default value and must be set the first  time a user runs DHTK.</p>"},{"location":"user_guide/#modifying-configurations","title":"Modifying configurations","text":"<p>Configurations can be set directly by passing their values as keyword arguments to the <code>dhtk.start()</code> function.</p>"},{"location":"user_guide/#dhtk-data-sources","title":"DHTK data sources","text":"<p>Using the settings, DHTK will determine which SPARQL endpoint to connect and which extension module to load. </p> <p>Currently, DHTK includes the following extensions:</p> <ul> <li>Project Gutenberg</li> <li>Auchinkleck manuscript</li> </ul>"},{"location":"user_guide/#gutenberg","title":"Gutenberg","text":"<p>DHTK's Gutenberg extension dataset allows the user to easily query Gutenberg.org for books, authors, bookshelves and subjects, retrieving all the available information as a DHTK Corpus.</p> <p>DHTK provides a simple dictionary-like syntax to search Guntenberg's dataset using the method .get(). This method allows the user to easily query the entire dataset using a single interface with only 3 keyword arguments:</p> <ul> <li>[what] to search for.</li> <li>[name] of what is being searched. If no name is provided, all     available options are retrieved.</li> <li>[add] to corpus or just search results?</li> </ul> <p></p>"},{"location":"user_guide/#exploring-data","title":"Exploring Data","text":"<p>To search Gutenberg's data, set add=False. For such queries, DHTK Gutenberg's module returns a dictionary of books or authors matching the query.</p> <p>note</p> <p>add=False is the default value, so this argument can be simply  ignored by the user in such cases.</p> <p>*Searching for a bookshelf*</p> <p>To check which bookshelves are available in DHTK's Gutenberg, set what=\"shelf\" and name=\"all\".</p> <p>note</p> <p>name=\"all\" is the default value, so this argument may be simply  ignored by the user.</p> <p>To search for books available for a bookshelf, the name, or part of the name, of an available bookshelf is passed to the name argument. For example, to search all books in \"Science Fiction\" bookshelves:</p> <p>The list of bookshelves matching the query are stored as the dictionary keys for easy access:</p> <p>The information for individual bookshelves can be easily retrieved using the dictionary key. This strutcture makes it easy to perform all types of regular Python operations. For example, to identify all books that are simultaneously found on the bookshelves \"Precursors of Science Fiction\" and \"Science Fiction by Women\":</p> <p>*Searching for a subject*</p> <p>Gutenberg subjects can be searched using what=\"subject\". Subject names are structured hierarchically, making it possible to define the granularity of such queries. Each hierarchy is separated by -- (e.g. Subject -- Sub-subject -- Sub-sub-subject)</p> <p>*Searching for a book*</p> <p>Gutenberg books can be searched using the what=\"book\" argument. This will return a dictionary of books containing the text passed as name. To avoid long names, the dictionary keys returned are truncated at 20 characters.</p> <p>*Searching for an author*</p> <p>Gutenberg books can be searched using the what=\"author\" argument.</p>"},{"location":"user_guide/#check-metadata","title":"Check metadata","text":"<p>DHTK Guntenberg's module uses books and authors objects to store all the relevant information retrieved. These objects can be accessed directly from the dictionaries obtained while searching as described above.</p> <p>note</p> <p>The book and author objects are not returned when searching for  bookshelves and subjects. These queries are considered more  exploratory and instantiating all objects would be less efficient in  respect to both performance and memory.</p> <p>*Get book information*</p> <p>Retrieving metadata is simple as all Gutenberg objects have the .print_info() method:</p> <p>*Get author information*</p> <p>Author objects are retrieved with author searches as described above. However, book objects also contain the author information as attribute. Because of this, there are two ways to access an author object:</p> <p>Accessing the author's information can be done as easily as for books, using the .print_info() method:</p> <p>*Get book text*</p> <p>The original text for a Gutenberg book can also be accessed if required, using the GutenbergBook method .original_text().</p>"},{"location":"user_guide/#saving-results","title":"Saving results","text":"<p>To add the retrieved book to a DHTK Corpus use add=True. A list of GutenbergBook objects is created containing all the textual data and metadata retrieved from Guntenberg.org.</p> <p>note</p> <p>Each query that uses add=True will add the resulting books to the  same module object. This means that a new module needs to be  instantiated with .get_module() function for each different  corpus</p> <p>*Make a Corpus*</p> <p>*Retrieve books*</p> <p>Individual books can be retrieved from a Gutenberg Corpus using the .books() method and passing a book name to the get argument.</p> <p>Passing the value get=\"all\" will return a dictionary of books added to the corpus.</p> <p>*Modifying Corpus*</p> <p>As seem in the \"Get book information\" above, the book Frankenstein; Or, The Modern Prometheus with ID http://www.gutenberg.org/ebooks/84 has \"an improved edition\". To remove the old edition, the argument remove=True can be passed to the method .books().</p> <p>Before saving the Corpus to disk, it is important to review the Corpus descriptions, particularly the corpus name, which is used as the directory where the books will be stored. This can be done simply by passing the name and description arguments to the .corpus() method used above.</p> <p>*Save Corpus*</p> <p>When all the information as been added to a corpus, it can be easily saved to disk using the .save() method.</p>"},{"location":"API/DHTK/","title":"DHTK","text":"<p>Utility functions used by all modules.</p> <p>Gutenberg extension data_source</p> <p>Auchinleck extension module</p>"},{"location":"API/DHTK/#dhtk.core.system.download_files","title":"<code>download_files(urls, path='./', file_names='')</code>","text":"<p>Function to download files from the Web.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>Union[str, List[str]]</code> <p>URLs of the files to be downloaded</p> required <code>path</code> <code>str</code> <p>Path to directory to store the downloaded files. (Default value = \"./\")</p> <code>'./'</code> <code>file_names</code> <code>typing.Union[str, typing.List[str]</code> <p>Output name or names of the files to be downloaded.</p> <code>''</code> Source code in <code>dhtk/core/system.py</code> <pre><code>def download_files(\n        urls: typing.Union[str, typing.List[str]],\n        path:  typing.Union[str, pathlib.Path] = \"./\",\n        file_names: typing.Optional[typing.Union[str, typing.List[str]]] = \"\") -&gt; \\\n        typing.Union[str, typing.List[str]]:\n    \"\"\"Function to download files from the Web.\n\n    Args:\n      urls (typing.Union[str, typing.List[str]]): URLs of the files to be downloaded\n      path (str, optional): Path to directory to store the downloaded files. (Default value = \"./\")\n      file_names (typing.Union[str, typing.List[str], optional): Output name or names of the files to be downloaded.\n\n\n    \"\"\"\n\n    # Convert inputs to list\n    if isinstance(urls, str):\n        urls = [urls]\n\n    if isinstance(path, str):\n        path = pathlib.Path(path)\n    path.mkdir(exist_ok=True)\n\n    # Request all files\n    get_file_names = False\n    if not file_names:\n        file_names = []\n        get_file_names = True\n    elif isinstance(file_names, str):\n        file_names = [file_names, ]\n    elif isinstance(file_names, list):\n        if len(file_names) != len(urls):\n            raise IndexError(\"The list of filenames should correspond to the list of urls.\")\n    for index, url in enumerate(urls):\n\n        if url_exists(url):  # Check if URL is valid\n            if get_file_names:\n                file_name = url.split('/')[-1]\n                file_name = file_name.split('?')[0]\n            else:\n                file_name = file_names[index]\n\n            file_paths: typing.List[pathlib.Path] = [path / file for file in file_names]\n            if all(file.exists() for file in file_paths):\n                if len(file_paths) == 1:\n                    return file_paths[0].name\n                return [file_path.name for file_path in file_paths]\n            # Make request\n            headers = {'User-Agent': get_platform()}\n            with requests.get(url, stream=True, headers=headers) as request:\n                request.raise_for_status()\n                chunk = 8192\n                total = int(request.headers['Content-Length'])\n\n                # Read to file\n                with open(path / file_name, 'wb') as out_file:\n                    with tqdm.tqdm(total=total, desc=f\"Downloading {file_name}\") as progress_bar:\n                        for part in request.iter_content(chunk_size=chunk):\n                            out_file.write(part)\n                            progress_bar.update(chunk)\n                logger.info(\"DOWNLOAD: %s downloaded from  %s to %s\", file_name, url, path)\n        else:  # Warn if URL is not valid\n            msg = f\"URL not available: {url}\"\n            warnings.warn(msg)\n            logger.warning(\"DOWNLOAD: %s\", msg)\n\n    if len(file_names) == 1:  # Return a string if there is only one file\n        file_names = file_names[0]\n\n    return file_names\n</code></pre>"},{"location":"API/DHTK/#dhtk.core.system.get_date","title":"<code>get_date(url)</code>","text":"<p>Function to get last modified date of a remote file</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>the url link</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>the datatime object</p> Source code in <code>dhtk/core/system.py</code> <pre><code>def get_date(url: str) -&gt; datetime.datetime:\n    \"\"\"Function to get last modified date of a remote file\n\n    Args:\n      url (str): the url link\n\n    Returns:\n      datetime (datetime): the datatime object\n    \"\"\"\n\n    headers = {'User-Agent': get_platform()}\n    request = requests.head(url, stream=True, headers=headers)\n    request = request.headers['last-modified']\n    last_update = datetime.datetime.strptime(request, '%a, %d %b %Y %H:%M:%S %Z')\n\n    return last_update\n</code></pre>"},{"location":"API/DHTK/#dhtk.core.system.get_platform","title":"<code>get_platform()</code>","text":"<p>Returns computes platform.</p> Source code in <code>dhtk/core/system.py</code> <pre><code>def get_platform():\n    \"\"\"Returns computes platform.\"\"\"\n    return f'\"({platform.system()}; U; {platform.architecture()[0]}; en-us)\"'\n</code></pre>"},{"location":"API/DHTK/#dhtk.core.system.make_dirs","title":"<code>make_dirs(directories)</code>","text":"<p>Function to create new directories at DHTK's initiation.</p> <p>Parameters:</p> Name Type Description Default <code>directories</code> <code>Union[str, List[str]]</code> <p>the new directory path</p> required Source code in <code>dhtk/core/system.py</code> <pre><code>def make_dirs(directories: typing.Union[str, typing.List[str]]) -&gt; None:\n    \"\"\"Function to create new directories at DHTK's initiation.\n\n    Args:\n      directories (typing.Union[str, typing.List[str]]): the new directory path\n\n    \"\"\"\n    # Convert values to list\n    if not isinstance(directories, list):\n        directories = [directories]\n\n    # For each directory, confirm value is a pathlib.Path object and directory doesn't exist\n    for directory in directories:\n        directory = pathlib.Path(directory)\n\n        if not directory.is_dir():\n            try:\n                directory.mkdir(parents=True, exist_ok=True)\n            except (IOError, PermissionError):\n                sys.exit(f\"Could not create {directory}, please check user rights.\")\n</code></pre>"},{"location":"API/DHTK/#dhtk.core.system.pip_install","title":"<code>pip_install(module_type, module)</code>","text":"<p>Helper function to install missing modules</p> <p>Parameters:</p> Name Type Description Default <code>module_type</code> <code>str</code> <p>possible values \"data_sources\"  or \"storage\"</p> required <code>module</code> <p>\"the dhtk module name\"</p> required <p>Returns:</p> Type Description <p>the imported module.</p> Source code in <code>dhtk/core/system.py</code> <pre><code>def pip_install(module_type, module):\n    \"\"\"\n    Helper function to install missing modules\n\n    Args:\n        module_type (str): possible values \"data_sources\"  or \"storage\"\n        module: \"the dhtk module name\"\n\n    Returns:\n        the imported module.\n\n    \"\"\"\n    if 'dummy' in module:\n        module_name = f\"dhtk_{module_type.rstrip('s')}_{module}\"\n        module_import = f\"dhtk.{module_type}.{module}\"\n        git_url = f\"git+ssh://git@gitlab.com/dhtk/dhtk_{module_type}/examples/{module_name}\"\n    else:\n        module_name = f\"dhtk_{module_type}_{module}\"\n        module_import = f\"dhtk.{module_type.rstrip('s')}.{module}\"\n        git_url = f\"git+ssh://git@gitlab.com/dhtk/dhtk_{module_type}s/{module_name}\"\n    if not IS_INTERACTIVE:\n        raise EnvironmentError(f\"This method is for interactive usage only! Please install {module_name} manually:\"\n                               f\"$ pip install {git_url}\")\n    answer = input(f\"Do you want dhtk to install {module_name}? [y/N]\")\n    if not answer.lower().startswith(\"y\"):\n        raise EnvironmentError(f\"Please install the module manually: $ pip install {git_url}\")\n    try:\n        cmd = ['-m', 'pip', 'install', git_url]\n        subprocess.check_call([sys.executable] + cmd)\n    except subprocess.CalledProcessError:\n        msg = f\"Module {module_name} not available.\"\n        warnings.warn(msg)\n        logger.error(\"DATASET: %s\", msg)\n    return importlib.import_module(\n        module_import\n    )\n</code></pre>"},{"location":"API/DHTK/#dhtk.core.system.url_exists","title":"<code>url_exists(url)</code>","text":"<p>Function to check if an url is available.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>the path to check</p> required Source code in <code>dhtk/core/system.py</code> <pre><code>def url_exists(url: str):\n    \"\"\"Function to check if an url is available.\n\n    Args:\n      url (str): the path to check\n\n    \"\"\"\n\n    # If the URL is a local file\n    if url.startswith(\"file:\"):\n        return pathlib.Path(url.split(\"/\", 1)[1]).exists()\n\n    # If URL is a remote file\n    try:\n        response = requests.head(url)\n    except requests.exceptions.ConnectionError:\n        return False\n    return response.ok\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.gutenberg.Module","title":"<code>Module</code>","text":"<p>               Bases: <code>AbstractDataSource</code></p> <p>Gutenberg Triplestore Class</p> Source code in <code>dhtk/data_sources/gutenberg/__init__.py</code> <pre><code>class Module(AbstractDataSource):\n    \"\"\"Gutenberg Triplestore Class\"\"\"\n    name = \"gutenberg\"\n    storage_type = \"triplestore\"\n    data_file = \"https://sandbox.zenodo.org/record/967894/files/gutenberg-dhtk-reasoned.ttl?download=1\"\n\n    @classmethod\n    def get_data_file(cls, output_path, storage_type):\n        \"\"\"\n        Get a content as defined in self.data_file and write into a file into output_path\n        Args:\n            output_path (Path): the path where to write (i.e. output_path = Path('WD/gutenberg/data/triplestore'))\n            storage_type (str): the type of the storage\n\n        Returns:\n            Path: the path to the file with data\n\n        \"\"\"\n        # output_path can be like this output_path = 'WD/gutenberg/data/triplestore'\n        # storage_type can be like this storage_type= 'triplestore'\n        if isinstance(cls.storage_type, str):\n            data_file = cls.data_file\n        else:\n            data_file = cls.storage_type[cls.storage_type.index(storage_type)]\n        download_files(data_file, output_path, \"gutenberg.ttl\")\n        return output_path / \"gutenberg.ttl\"\n\n    def __init__(self, working_directory, endpoints):\n\n        # Get the extension\n        self.wrapper = GutenbergData(sparql_endpoint=endpoints[0])\n        self.types = [\"author\", \"book\", \"shelf\", \"subject\"]\n\n    def welcome(self):\n        \"\"\"\n\n        \"\"\"\n        stats = None\n        for check in range(10):\n            try:\n                stats = self.wrapper.statistics()\n                break\n            except (RemoteDisconnected, URLError, ConnectionResetError):\n                if check &gt;= 9:\n                    warnings.warn(\"WARNING: There is a problem with the connection!\")\n                    print(\"Probably Docker is slow to restart!\")\n                    stats = \"\\nNo statistics available\"\n                    break\n                sleep(10)\n        print(stats)\n\n    def get(self, what, name_or_id):\n        \"\"\"\n        Extension wrapper method to call all DHTK functionalities with a simple syntax\n\n        Parameters\n        ----------\n        what: string\n            Type of information to retrieve.\n            DHTK Gutenberg has the options to search for books, authors, shelves and subjects\n        name_or_id: string\n            Name identifying the specific information to retrieve.\n\n        Returns\n        -------\n        Requested book information from Gutenberg dataset\n        \"\"\"\n        dispatch = {\n            \"book_id\": self.wrapper.get_book,\n            \"book\": self.wrapper.search_by_title,\n            \"author_id\": self.wrapper.get_author,\n            \"author\": self.wrapper.search_by_author,\n            \"shelf\": self.wrapper.search_by_bookshelf,\n            \"subject\": self.wrapper.search_by_subject,\n        }\n        try:\n            if what in dispatch:\n                if isinstance(name_or_id, str):\n                    results = dispatch[what](name_or_id, works=True)\n                else:\n                    results = dispatch[what](*name_or_id, works=True)\n                return results\n        except ValueError as error:\n            valid = '\", \"'.join(list(dispatch.keys()))\n            raise ValueError(\n                f'Could not find what you are searching for, valid entries for \"what\" are:\\n[\"{valid}\"]'\n            ) from error\n\n    def search(self, what, name_or_id=\"all\"):\n        \"\"\"\n\n        Args:\n            what:\n            name_or_id:\n\n        Returns:\n\n        \"\"\"\n        dispatch = {\n            \"book_id\": self.wrapper.get_book,\n            \"book\": self.wrapper.search_by_title,\n            \"author_id\": self.wrapper.get_author,\n            \"author\": self.wrapper.search_by_author,\n            \"shelf\": self.wrapper.search_by_bookshelf,\n            \"subject\": self.wrapper.search_by_subject,\n            \"all_book\": self.wrapper.all_books,\n            \"all_author\": self.wrapper.all_authors,\n            \"all_subject\": self.wrapper.all_subjects,\n            \"all_shelf\": self.wrapper.all_bookshelves,\n        }\n\n        try:\n            if name_or_id == \"all\":\n                what = \"all_\" + what\n                if what in dispatch:\n                    return dispatch[what]()\n            elif what in dispatch:\n                if isinstance(name_or_id, str):\n                    results = dispatch[what](name_or_id, works=False)\n                else:\n                    results = dispatch[what](*name_or_id, works=False)\n                return results\n        except ValueError as error:\n            valid = '\\\", \\\"'.join([value for value in dispatch if not value.startswith('all_')])\n            raise ValueError(\n                f'Could not find what you are searching for, valid entries for \"what\" are:\\n[\"{valid}\"]'\n            ) from error\n\n    def query(self, query):\n        \"\"\"\n\n        Args:\n            query:\n\n        Returns:\n\n        \"\"\"\n        return self.wrapper.query(query)\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.gutenberg.Module.get","title":"<code>get(what, name_or_id)</code>","text":"<p>Extension wrapper method to call all DHTK functionalities with a simple syntax</p>"},{"location":"API/DHTK/#dhtk.data_sources.gutenberg.Module.get--parameters","title":"Parameters","text":"<p>what: string     Type of information to retrieve.     DHTK Gutenberg has the options to search for books, authors, shelves and subjects name_or_id: string     Name identifying the specific information to retrieve.</p>"},{"location":"API/DHTK/#dhtk.data_sources.gutenberg.Module.get--returns","title":"Returns","text":"<p>Requested book information from Gutenberg dataset</p> Source code in <code>dhtk/data_sources/gutenberg/__init__.py</code> <pre><code>def get(self, what, name_or_id):\n    \"\"\"\n    Extension wrapper method to call all DHTK functionalities with a simple syntax\n\n    Parameters\n    ----------\n    what: string\n        Type of information to retrieve.\n        DHTK Gutenberg has the options to search for books, authors, shelves and subjects\n    name_or_id: string\n        Name identifying the specific information to retrieve.\n\n    Returns\n    -------\n    Requested book information from Gutenberg dataset\n    \"\"\"\n    dispatch = {\n        \"book_id\": self.wrapper.get_book,\n        \"book\": self.wrapper.search_by_title,\n        \"author_id\": self.wrapper.get_author,\n        \"author\": self.wrapper.search_by_author,\n        \"shelf\": self.wrapper.search_by_bookshelf,\n        \"subject\": self.wrapper.search_by_subject,\n    }\n    try:\n        if what in dispatch:\n            if isinstance(name_or_id, str):\n                results = dispatch[what](name_or_id, works=True)\n            else:\n                results = dispatch[what](*name_or_id, works=True)\n            return results\n    except ValueError as error:\n        valid = '\", \"'.join(list(dispatch.keys()))\n        raise ValueError(\n            f'Could not find what you are searching for, valid entries for \"what\" are:\\n[\"{valid}\"]'\n        ) from error\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.gutenberg.Module.get_data_file","title":"<code>get_data_file(output_path, storage_type)</code>  <code>classmethod</code>","text":"<p>Get a content as defined in self.data_file and write into a file into output_path Args:     output_path (Path): the path where to write (i.e. output_path = Path('WD/gutenberg/data/triplestore'))     storage_type (str): the type of the storage</p> <p>Returns:</p> Name Type Description <code>Path</code> <p>the path to the file with data</p> Source code in <code>dhtk/data_sources/gutenberg/__init__.py</code> <pre><code>@classmethod\ndef get_data_file(cls, output_path, storage_type):\n    \"\"\"\n    Get a content as defined in self.data_file and write into a file into output_path\n    Args:\n        output_path (Path): the path where to write (i.e. output_path = Path('WD/gutenberg/data/triplestore'))\n        storage_type (str): the type of the storage\n\n    Returns:\n        Path: the path to the file with data\n\n    \"\"\"\n    # output_path can be like this output_path = 'WD/gutenberg/data/triplestore'\n    # storage_type can be like this storage_type= 'triplestore'\n    if isinstance(cls.storage_type, str):\n        data_file = cls.data_file\n    else:\n        data_file = cls.storage_type[cls.storage_type.index(storage_type)]\n    download_files(data_file, output_path, \"gutenberg.ttl\")\n    return output_path / \"gutenberg.ttl\"\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.gutenberg.Module.query","title":"<code>query(query)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>query</code> required <p>Returns:</p> Source code in <code>dhtk/data_sources/gutenberg/__init__.py</code> <pre><code>def query(self, query):\n    \"\"\"\n\n    Args:\n        query:\n\n    Returns:\n\n    \"\"\"\n    return self.wrapper.query(query)\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.gutenberg.Module.search","title":"<code>search(what, name_or_id='all')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>what</code> required <code>name_or_id</code> <code>'all'</code> <p>Returns:</p> Source code in <code>dhtk/data_sources/gutenberg/__init__.py</code> <pre><code>def search(self, what, name_or_id=\"all\"):\n    \"\"\"\n\n    Args:\n        what:\n        name_or_id:\n\n    Returns:\n\n    \"\"\"\n    dispatch = {\n        \"book_id\": self.wrapper.get_book,\n        \"book\": self.wrapper.search_by_title,\n        \"author_id\": self.wrapper.get_author,\n        \"author\": self.wrapper.search_by_author,\n        \"shelf\": self.wrapper.search_by_bookshelf,\n        \"subject\": self.wrapper.search_by_subject,\n        \"all_book\": self.wrapper.all_books,\n        \"all_author\": self.wrapper.all_authors,\n        \"all_subject\": self.wrapper.all_subjects,\n        \"all_shelf\": self.wrapper.all_bookshelves,\n    }\n\n    try:\n        if name_or_id == \"all\":\n            what = \"all_\" + what\n            if what in dispatch:\n                return dispatch[what]()\n        elif what in dispatch:\n            if isinstance(name_or_id, str):\n                results = dispatch[what](name_or_id, works=False)\n            else:\n                results = dispatch[what](*name_or_id, works=False)\n            return results\n    except ValueError as error:\n        valid = '\\\", \\\"'.join([value for value in dispatch if not value.startswith('all_')])\n        raise ValueError(\n            f'Could not find what you are searching for, valid entries for \"what\" are:\\n[\"{valid}\"]'\n        ) from error\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.gutenberg.Module.welcome","title":"<code>welcome()</code>","text":"Source code in <code>dhtk/data_sources/gutenberg/__init__.py</code> <pre><code>def welcome(self):\n    \"\"\"\n\n    \"\"\"\n    stats = None\n    for check in range(10):\n        try:\n            stats = self.wrapper.statistics()\n            break\n        except (RemoteDisconnected, URLError, ConnectionResetError):\n            if check &gt;= 9:\n                warnings.warn(\"WARNING: There is a problem with the connection!\")\n                print(\"Probably Docker is slow to restart!\")\n                stats = \"\\nNo statistics available\"\n                break\n            sleep(10)\n    print(stats)\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.auchinleck.Module","title":"<code>Module</code>","text":"<p>               Bases: <code>AbstractDataSource</code></p> <p>Auchinleck Triplestore Class</p> Source code in <code>dhtk/data_sources/auchinleck/__init__.py</code> <pre><code>class Module(AbstractDataSource):\n    \"\"\"Auchinleck Triplestore Class\"\"\"\n    name = \"auchinleck\"\n    storage_type = \"triplestore\"\n    data_file = \"https://sandbox.zenodo.org/record/730187/files/auchinleck_data.rdf?download=1\"\n\n    @classmethod\n    def get_data_file(cls, output_path, storage_type):\n        if isinstance(cls.storage_type, str):\n            data_file = cls.data_file\n        else:\n            data_file = cls.storage_type[cls.storage_type.index(storage_type)]\n        download_files(data_file, output_path, \"auchinleck_data.rdf\")\n        return output_path / \"auchinleck_data.rdf\"\n\n    def __init__(self, working_directory, endpoints):\n\n        # Defaults required to be defined for each extension\n\n        # Get the extension\n        self.wrapper = AuchinleckData(sparql_endpoint=endpoints[0])\n\n        # Instantiate the list of results\n        self._results = []\n\n    def welcome(self):\n        for check in range(10):\n            try:\n                stats = self.wrapper.statistics()\n                break\n            except (RemoteDisconnected, URLError):\n                if check &gt;= 9:\n                    warnings.warn(\"WARNING: There is a problem with the connection!\")\n                    print(\"Probably Docker is slow to restart!\")\n                    break\n                sleep(10)\n\n    def get(self, what, option, custom_option=None, add=False):\n        \"\"\"\n        Extension wrapper method to call all DHTK functionalities with a simple syntax\n\n        Examples\n        -------\n            ::\n\n            get('word list','French)\n\n            get('manuscript years', 'king')\n\n            get('poem lexicon', 'Sir Tristrem')\n\n            get(\n                'custom query',\n                'SELECT ?subject ?predicate ?object WHERE {?subject ?predicate ?object} LIMIT 25',\n                ['subject', 'predicate', 'object']\n            )\n\n        Parameters\n        ----------\n        what: string\n            Type of information to retrieve.\n            Possible values are:\n            - 'word list' to search for a list of words of a specific etymology\n            - 'manuscript years' to search for the earliest years a word appeared in Middle English (based on manuscripts)\n            - 'composition years' to search for the earliest years a word appeared in Middle English (based on composition)\n            - 'dictionary form' to search for the dictionary form of a word in the Middle English Dictionary\n            - 'poem lexicon' to search for the lexicon words of a specific poem\n            - 'custom query' to search for the database using a custom SPARQL query\n        option: string\n            Options for the type of information to retrieve. If 'what' parameter value is:\n            - 'word list' options must be one of the etymologies, that is, 'French', 'English', 'Latin', 'Scandinavian', 'Unknown', 'Other'\n            - 'manuscript years', 'composition years', 'dictionary form' require a word of the Auchinleck lexicon, as a string.\n            - 'poem lexicon' option must be the title of one of Auchinleck poems, as a string.\n            - 'custom query' option\n        custom_option: list\n            This parameter is to be used only with a custom query. The option must be a list of the desired variables\n            to be searched by the custom SPARQL query.\n\n        Returns\n        -------\n        Requested information from Auchinleck dataset as a list of dictionaries\n        \"\"\"\n        if not custom_option:\n            custom_option = []\n\n        # Prepare arguments\n        option = option.strip().lower()\n        what = what.strip().lower()\n\n        if what == \"words list\":\n            if option == \"french\":\n                response = self.wrapper.get_french_words()\n            elif option == \"english\":\n                response = self.wrapper.get_english_words()\n            elif option == \"latin\":\n                response = self.wrapper.get_latin_words()\n            elif option == \"scandinavian\":\n                response = self.wrapper.get_scandinavian_words()\n            elif option == \"other\":\n                response = self.wrapper.get_other_words()\n            elif option == \"unknown\":\n                response = self.wrapper.get_unknown_words()\n            else:\n                warnings.warn(\"Not a valid option\")\n                print(\"Allowed options for words list are:\"\n                      \"\\nFrench\\nEnglish\\nLatin\\nScandinavian\\nOther\\nUnknown\")\n                return\n        elif what == \"manuscript years\":\n            if option.isalnum():\n                response = self.wrapper.get_manuscript_year(option)\n            else:\n                warnings.warn(\"Not a valid option\")\n                print(\"Allowed option for manuscript years is a string (lexicon word)\")\n                return\n        elif what == \"composition years\":\n            if option.isalnum():\n                response = self.wrapper.get_composition_year(option)\n            else:\n                warnings.warn(\"Not a valid option\")\n                print(\"Allowed option for composition years is a string (lexicon word)\")\n                return\n        elif what == \"dictionary form\":\n            if option.isalnum():\n                response = self.wrapper.get_manuscript_year(option)\n            else:\n                warnings.warn(\"Not a valid option\")\n                print(\"Allowed option for dictionary form is a string (lexicon word)\")\n                return\n        elif what == \"poem lexicon\":\n            if option.isalnum():\n                response = self.wrapper.get_poem_lexicon(option)\n            else:\n                warnings.warn(\"Not a valid option\")\n                print(\"Allowed option for poem lexicon is a string (poem title)\")\n                return\n        elif what == \"custom query\":\n            if option.isalnum() and type(custom_option) is list:\n                response = self.wrapper.get_custom_query(option, custom_option)\n            else:\n                warnings.warn(\"Not a valid option\")\n                print(\"Allowed options for custom query is a string and a list\")\n                return\n        else:\n            warnings.warn(\"Not a valid option\")\n            print(\"\"\"Allowed arguments are\n            \\nwords list\\nmanuscript years\\ncomposition years\\ndictionary form\n            \\npoem lexicon\\ncustom query\"\"\")\n            return\n\n        if not response:\n            response = \"\\n\".join([f\"No {what} found.\",\n                                  \"Please make sure there are no spelling mistakes.\"])\n            print(response)\n            return\n        else:\n            self._results = response\n            return response\n\n    def save(self):\n        \"\"\"\n        Saves the requested information from the Auchinleck dataset as pandas.DataFrame\n        to a pickle dump.\n\n        \"\"\"\n\n        # Prepare save directory\n        path = os.getcwd()\n\n        # Save Python Query Object\n        with open(path + \"results.pk\", 'wb') as pickled_file:\n            pickle.dump(pd.DataFrame(self._results), pickled_file, protocol=pickle.HIGHEST_PROTOCOL)\n        pickled_file.close()\n\n    def search(self, what, name_or_id):\n        pass\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.auchinleck.Module.get","title":"<code>get(what, option, custom_option=None, add=False)</code>","text":"<p>Extension wrapper method to call all DHTK functionalities with a simple syntax</p>"},{"location":"API/DHTK/#dhtk.data_sources.auchinleck.Module.get--examples","title":"Examples","text":"<pre><code>::\n\nget('word list','French)\n\nget('manuscript years', 'king')\n\nget('poem lexicon', 'Sir Tristrem')\n\nget(\n    'custom query',\n    'SELECT ?subject ?predicate ?object WHERE {?subject ?predicate ?object} LIMIT 25',\n    ['subject', 'predicate', 'object']\n)\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.auchinleck.Module.get--parameters","title":"Parameters","text":"<p>what: string     Type of information to retrieve.     Possible values are:     - 'word list' to search for a list of words of a specific etymology     - 'manuscript years' to search for the earliest years a word appeared in Middle English (based on manuscripts)     - 'composition years' to search for the earliest years a word appeared in Middle English (based on composition)     - 'dictionary form' to search for the dictionary form of a word in the Middle English Dictionary     - 'poem lexicon' to search for the lexicon words of a specific poem     - 'custom query' to search for the database using a custom SPARQL query option: string     Options for the type of information to retrieve. If 'what' parameter value is:     - 'word list' options must be one of the etymologies, that is, 'French', 'English', 'Latin', 'Scandinavian', 'Unknown', 'Other'     - 'manuscript years', 'composition years', 'dictionary form' require a word of the Auchinleck lexicon, as a string.     - 'poem lexicon' option must be the title of one of Auchinleck poems, as a string.     - 'custom query' option custom_option: list     This parameter is to be used only with a custom query. The option must be a list of the desired variables     to be searched by the custom SPARQL query.</p>"},{"location":"API/DHTK/#dhtk.data_sources.auchinleck.Module.get--returns","title":"Returns","text":"<p>Requested information from Auchinleck dataset as a list of dictionaries</p> Source code in <code>dhtk/data_sources/auchinleck/__init__.py</code> <pre><code>def get(self, what, option, custom_option=None, add=False):\n    \"\"\"\n    Extension wrapper method to call all DHTK functionalities with a simple syntax\n\n    Examples\n    -------\n        ::\n\n        get('word list','French)\n\n        get('manuscript years', 'king')\n\n        get('poem lexicon', 'Sir Tristrem')\n\n        get(\n            'custom query',\n            'SELECT ?subject ?predicate ?object WHERE {?subject ?predicate ?object} LIMIT 25',\n            ['subject', 'predicate', 'object']\n        )\n\n    Parameters\n    ----------\n    what: string\n        Type of information to retrieve.\n        Possible values are:\n        - 'word list' to search for a list of words of a specific etymology\n        - 'manuscript years' to search for the earliest years a word appeared in Middle English (based on manuscripts)\n        - 'composition years' to search for the earliest years a word appeared in Middle English (based on composition)\n        - 'dictionary form' to search for the dictionary form of a word in the Middle English Dictionary\n        - 'poem lexicon' to search for the lexicon words of a specific poem\n        - 'custom query' to search for the database using a custom SPARQL query\n    option: string\n        Options for the type of information to retrieve. If 'what' parameter value is:\n        - 'word list' options must be one of the etymologies, that is, 'French', 'English', 'Latin', 'Scandinavian', 'Unknown', 'Other'\n        - 'manuscript years', 'composition years', 'dictionary form' require a word of the Auchinleck lexicon, as a string.\n        - 'poem lexicon' option must be the title of one of Auchinleck poems, as a string.\n        - 'custom query' option\n    custom_option: list\n        This parameter is to be used only with a custom query. The option must be a list of the desired variables\n        to be searched by the custom SPARQL query.\n\n    Returns\n    -------\n    Requested information from Auchinleck dataset as a list of dictionaries\n    \"\"\"\n    if not custom_option:\n        custom_option = []\n\n    # Prepare arguments\n    option = option.strip().lower()\n    what = what.strip().lower()\n\n    if what == \"words list\":\n        if option == \"french\":\n            response = self.wrapper.get_french_words()\n        elif option == \"english\":\n            response = self.wrapper.get_english_words()\n        elif option == \"latin\":\n            response = self.wrapper.get_latin_words()\n        elif option == \"scandinavian\":\n            response = self.wrapper.get_scandinavian_words()\n        elif option == \"other\":\n            response = self.wrapper.get_other_words()\n        elif option == \"unknown\":\n            response = self.wrapper.get_unknown_words()\n        else:\n            warnings.warn(\"Not a valid option\")\n            print(\"Allowed options for words list are:\"\n                  \"\\nFrench\\nEnglish\\nLatin\\nScandinavian\\nOther\\nUnknown\")\n            return\n    elif what == \"manuscript years\":\n        if option.isalnum():\n            response = self.wrapper.get_manuscript_year(option)\n        else:\n            warnings.warn(\"Not a valid option\")\n            print(\"Allowed option for manuscript years is a string (lexicon word)\")\n            return\n    elif what == \"composition years\":\n        if option.isalnum():\n            response = self.wrapper.get_composition_year(option)\n        else:\n            warnings.warn(\"Not a valid option\")\n            print(\"Allowed option for composition years is a string (lexicon word)\")\n            return\n    elif what == \"dictionary form\":\n        if option.isalnum():\n            response = self.wrapper.get_manuscript_year(option)\n        else:\n            warnings.warn(\"Not a valid option\")\n            print(\"Allowed option for dictionary form is a string (lexicon word)\")\n            return\n    elif what == \"poem lexicon\":\n        if option.isalnum():\n            response = self.wrapper.get_poem_lexicon(option)\n        else:\n            warnings.warn(\"Not a valid option\")\n            print(\"Allowed option for poem lexicon is a string (poem title)\")\n            return\n    elif what == \"custom query\":\n        if option.isalnum() and type(custom_option) is list:\n            response = self.wrapper.get_custom_query(option, custom_option)\n        else:\n            warnings.warn(\"Not a valid option\")\n            print(\"Allowed options for custom query is a string and a list\")\n            return\n    else:\n        warnings.warn(\"Not a valid option\")\n        print(\"\"\"Allowed arguments are\n        \\nwords list\\nmanuscript years\\ncomposition years\\ndictionary form\n        \\npoem lexicon\\ncustom query\"\"\")\n        return\n\n    if not response:\n        response = \"\\n\".join([f\"No {what} found.\",\n                              \"Please make sure there are no spelling mistakes.\"])\n        print(response)\n        return\n    else:\n        self._results = response\n        return response\n</code></pre>"},{"location":"API/DHTK/#dhtk.data_sources.auchinleck.Module.save","title":"<code>save()</code>","text":"<p>Saves the requested information from the Auchinleck dataset as pandas.DataFrame to a pickle dump.</p> Source code in <code>dhtk/data_sources/auchinleck/__init__.py</code> <pre><code>def save(self):\n    \"\"\"\n    Saves the requested information from the Auchinleck dataset as pandas.DataFrame\n    to a pickle dump.\n\n    \"\"\"\n\n    # Prepare save directory\n    path = os.getcwd()\n\n    # Save Python Query Object\n    with open(path + \"results.pk\", 'wb') as pickled_file:\n        pickle.dump(pd.DataFrame(self._results), pickled_file, protocol=pickle.HIGHEST_PROTOCOL)\n    pickled_file.close()\n</code></pre>"}]}